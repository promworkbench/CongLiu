package congliu.processminig.XPortSoftwareEventlogTransformation;

import java.util.ArrayList;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryNaiveImpl;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

import XESSoftwareExtension.XSoftwareExtension;
import congliu.processmining.softwareprocessmining.InitializeSoftwareEventLog;
import congliu.processmining.softwareprocessmining.OrderingEventsNano;

/**
 * this plugin aim to re-factoring the raw software execution data by XPort(from Maikel) generated by the Pattern1 software
 * (1) add caller stuff to main();
 * (2) add object information to construct; because for some constructor, we lost the start event during the instrumentation, 
 * this is the main difference from the previous version, "SoftwareLogRefacroingPlugin.java"
 * (3) combine start & complete to one. with two nano-seconds
 * (4) XES logging on: https://svn.win.tue.nl/repos/prom/XPort/ are used.
 * 
 * 
 * (5)<!important feature!> for each run method, we have the start and end event but missing the object, just like the main. 
 * In addition, for some methods that are invoked by run, we have their caller information. 
 * The aim of this plug-in is to create full description for run.....
 * 
 * 
 * Results: only those run() methods that invoke methods have class object id. 
 * 
 * 
 * Updates: adding parameter values for normal methods. 
 * @author cliu3
 *
 */

@Plugin(
		name = "Repairing XPort based Software Event Log Generated by Pattern1 software",// plugin name
		
		returnLabels = {"A Software Event Log"}, //return labels
		returnTypes = {XLog.class},//return class
		
		//input parameter labels, corresponding with the second parameter of main function
		parameterLabels = {"Software Event Log"},
		
		userAccessible = true,
		help = "This plugin aims to repair software event log collected by Maikel Leemans XPort instrumentation using Pattern1 software provided by Boudewijn" 
		)
public class SoftwareLogRepairingPlugin {
	@UITopiaVariant(
	        affiliation = "TU/e", 
	        author = "Cong liu", 
	        email = "c.liu.3@tue.nl OR liucongchina@163.com"
	        )
	@PluginVariant(
			variantLabel = "Repairing XPort based Software Event Log Generated by Pattern1 software, default",
			// the number of required parameters, {0} means one input parameter
			requiredParameterLabels = {0}
			)
	public static XLog preprocessing(UIPluginContext context, XLog originalLog)
	{
		return repairing(originalLog);
	}
	
	public static XLog repairing(XLog originalLog)
	{
		// the refactored log.
		XFactory factory = new XFactoryNaiveImpl();
		
		// input the log name and a factory.
		XLog repairedLog =InitializeSoftwareEventLog.initialize(factory, XConceptExtension.instance().extractName(originalLog));
		
			
		int i =0;// add the trace id.
		
		int mainFlag =0;// this is to denote if the current log has main, for some test programs, no main can be found. 
		for(XTrace originalTrace: originalLog)
		{
			i++; // the execution id starts from 1.
			XTrace repairedTrace = factory.createTrace();// create the new trace
			XConceptExtension.instance().assignName(repairedTrace, "execution"+i);// add trace name
			
			// add the main
			String startTimenano = "";
			String endTimenano = "";
			String pacClassMethodMain ="";
			String classObjectMain = "@execution"+i; // add manual class object for main.
			int lineNumber =-1;
			int threadID = -1;
			
			for(XEvent originalEvent: originalTrace)// get the attribute of main();
			{
				if (XConceptExtension.instance().extractName(originalEvent).contains("main(java.lang.String[])"))
				{
					// main is found.
					mainFlag =1;
					if (XLifecycleExtension.instance().extractTransition(originalEvent).equals("start"))
						// main start event, get the start time and pac+class name
					{
						startTimenano = ((XAttributeLiteral) originalEvent.getAttributes().get("apprun:nanotime")).getValue();
						pacClassMethodMain = XConceptExtension.instance().extractName(originalEvent);
						lineNumber = Integer.parseInt(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:linenr")).getValue());
						threadID = Integer.parseInt(((XAttributeLiteral) originalEvent.getAttributes().get("apprun:threadid")).getValue());
					}
					if (XLifecycleExtension.instance().extractTransition(originalEvent).equals("complete"))
					{
						endTimenano = ((XAttributeLiteral) originalEvent.getAttributes().get("apprun:nanotime")).getValue();
					}
				}
			}
			
			// add main event to trace
			if (mainFlag==1)
			{
				XEvent mainEvent = factory.createEvent();
				XConceptExtension.instance().assignName(mainEvent, GetMathodClassPackages.extractMethod(pacClassMethodMain));
				XLifecycleExtension.instance().assignTransition(mainEvent, "start");
				XSoftwareExtension.instance().assignClass(mainEvent, GetMathodClassPackages.extractClass(pacClassMethodMain));
				XSoftwareExtension.instance().assignPackage(mainEvent, GetMathodClassPackages.extractPackage(pacClassMethodMain));
				XSoftwareExtension.instance().assignClassObject(mainEvent, classObjectMain);
				XSoftwareExtension.instance().assignCallermethod(mainEvent, "null");// the caller are null for main.
				XSoftwareExtension.instance().assignCallerclass(mainEvent, "null");
				XSoftwareExtension.instance().assignCallerclassobject(mainEvent, "null");
				XSoftwareExtension.instance().assignCallerpackage(mainEvent, "null");
				XSoftwareExtension.instance().assignStarttimenano(mainEvent, startTimenano);
				XSoftwareExtension.instance().assignEndtimenano(mainEvent, endTimenano);
				XSoftwareExtension.instance().assignLineNumber(mainEvent, lineNumber);
				XSoftwareExtension.instance().assignThreadID(mainEvent, threadID);
				XSoftwareExtension.instance().assignParameterTypeSet(mainEvent, GetMathodClassPackages.extractParameterSet(pacClassMethodMain));
				
				repairedTrace.add(mainEvent);
			}
			// add constructor method calls.
		
			// this is used to store all constructor names. can be further used to detect if the caller is a constructor. 
			ArrayList<String> constructorJoinPointNames = new ArrayList<>();
			for(XEvent originalEvent: originalTrace)
			{
				if(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:etype")).getValue().equals("call_new"))
				{
					// add constructor event to trace
					XEvent constructorEvent = factory.createEvent();
					// add all constructor names to a list
					constructorJoinPointNames.add(XConceptExtension.instance().extractName(originalEvent));
					
					// check if the constructor event is start or complete, this is because sometimes start constructor event is missing. 
					if (XLifecycleExtension.instance().extractTransition(originalEvent).equals("start"))// the constructor is start
					{	
						XConceptExtension.instance().assignName(constructorEvent, "init()");
						XLifecycleExtension.instance().assignTransition(constructorEvent, "start");
						XSoftwareExtension.instance().assignClass(constructorEvent, 
						GetMathodClassPackages.extractConstructorClass(XConceptExtension.instance().extractName(originalEvent)));
						XSoftwareExtension.instance().assignPackage(constructorEvent, 
						GetMathodClassPackages.extractConstructorPackage(XConceptExtension.instance().extractName(originalEvent)));
						XSoftwareExtension.instance().assignStarttimenano(constructorEvent, 
								((XAttributeLiteral) originalEvent.getAttributes().get("apprun:nanotime")).getValue());// start timestamp
						
						XSoftwareExtension.instance().assignParameterTypeSet(constructorEvent, 
								GetMathodClassPackages.extractParameterSet(XConceptExtension.instance().extractName(originalEvent)));	
						XSoftwareExtension.instance().assignLineNumber(constructorEvent,
								Integer.parseInt(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:linenr")).getValue()));
						XSoftwareExtension.instance().assignThreadID(constructorEvent,
								Integer.parseInt(((XAttributeLiteral) originalEvent.getAttributes().get("apprun:threadid")).getValue()));
						
						
						//find its corresponding complete constructor event to add the object information
						//get the complete constructor of the current start constructor.
						XSoftwareExtension.instance().assignClassObject(constructorEvent, 
							((XAttributeLiteral) SoftwareLogRefactoringPluginV1.getCompleteConstructorEvent(originalTrace.indexOf(originalEvent),originalTrace,originalEvent)
									.getAttributes().get("apploc:idhashcode")).getValue());
						XSoftwareExtension.instance().assignEndtimenano(constructorEvent, 
								((XAttributeLiteral) SoftwareLogRefactoringPluginV1.getCompleteConstructorEvent(originalTrace.indexOf(originalEvent),originalTrace,originalEvent)
										.getAttributes().get("apprun:nanotime")).getValue());// complete timestamp
						
					}
					else{ // the constructor is complete, i.e., the start constructor event is missing
						XConceptExtension.instance().assignName(constructorEvent, "init()");
						XLifecycleExtension.instance().assignTransition(constructorEvent, "start");
						XSoftwareExtension.instance().assignClass(constructorEvent, 
						GetMathodClassPackages.extractConstructorClass(XConceptExtension.instance().extractName(originalEvent)));
						XSoftwareExtension.instance().assignPackage(constructorEvent, 
						GetMathodClassPackages.extractConstructorPackage(XConceptExtension.instance().extractName(originalEvent)));
						XSoftwareExtension.instance().assignEndtimenano(constructorEvent, 
								((XAttributeLiteral) originalEvent.getAttributes().get("apprun:nanotime")).getValue());// end timestamp
						XSoftwareExtension.instance().assignClassObject(constructorEvent, 
								((XAttributeLiteral) originalEvent.getAttributes().get("apploc:idhashcode")).getValue());
						
						XSoftwareExtension.instance().assignParameterTypeSet(constructorEvent, 
								GetMathodClassPackages.extractParameterSet(XConceptExtension.instance().extractName(originalEvent)));	
						XSoftwareExtension.instance().assignLineNumber(constructorEvent,
								Integer.parseInt(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:linenr")).getValue()));
						XSoftwareExtension.instance().assignThreadID(constructorEvent,
								Integer.parseInt(((XAttributeLiteral) originalEvent.getAttributes().get("apprun:threadid")).getValue()));
						
						//find its corresponding start constructor event (actually the first callee event) to add the start time information. 
						XSoftwareExtension.instance().assignStarttimenano(constructorEvent, 
								((XAttributeLiteral) SoftwareLogRefactoringPluginV1.getFirstCalleeofConstructorEvent(originalTrace.indexOf(originalEvent),originalTrace,originalEvent)
										.getAttributes().get("apprun:nanotime")).getValue());// start timestamp
					}
					
					// add caller information
					if (((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue().contains("main(java.lang.String[])"))
					{
						if (mainFlag==1)// the log contains main, i.e., pacClassMethodMain is not null;
						{
							XSoftwareExtension.instance().assignCallermethod(constructorEvent, GetMathodClassPackages.extractMethod(pacClassMethodMain));
							XSoftwareExtension.instance().assignCallerclass(constructorEvent, GetMathodClassPackages.extractClass(pacClassMethodMain));
							XSoftwareExtension.instance().assignCallerclassobject(constructorEvent, classObjectMain);
							XSoftwareExtension.instance().assignCallerpackage(constructorEvent, GetMathodClassPackages.extractPackage(pacClassMethodMain));
							//XSoftwareExtension.instance().assignCallercomponent(event, callerComponentName);
						}
						else{// pacClassMethodMain is null
							XSoftwareExtension.instance().assignCallermethod(constructorEvent, GetMathodClassPackages.extractMethod(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
							XSoftwareExtension.instance().assignCallerclass(constructorEvent, GetMathodClassPackages.extractClass(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
							XSoftwareExtension.instance().assignCallerclassobject(constructorEvent, classObjectMain);
							XSoftwareExtension.instance().assignCallerpackage(constructorEvent, GetMathodClassPackages.extractPackage(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
						}
						
					}
					else// if the caller of the current method is not main()
					{
						// if the caller of the current method is not a constructor.
						if(!constructorJoinPointNames.contains(((XAttributeLiteral)originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()))
						{
							XSoftwareExtension.instance().assignCallermethod(constructorEvent, 
									GetMathodClassPackages.extractMethod(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
							XSoftwareExtension.instance().assignCallerclass(constructorEvent, 
									GetMathodClassPackages.extractClass(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
							XSoftwareExtension.instance().assignCallerclassobject(constructorEvent, 
									((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:idhashcode")).getValue());
							XSoftwareExtension.instance().assignCallerpackage(constructorEvent, 
									GetMathodClassPackages.extractPackage(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
						}
						else // if the caller is a constructor.
						{
							XSoftwareExtension.instance().assignCallermethod(constructorEvent, "init()");
							XSoftwareExtension.instance().assignCallerclass(constructorEvent, 
									GetMathodClassPackages.extractConstructorClass(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
							XSoftwareExtension.instance().assignCallerclassobject(constructorEvent, 
									((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:idhashcode")).getValue());
							XSoftwareExtension.instance().assignCallerpackage(constructorEvent, 
									GetMathodClassPackages.extractConstructorPackage(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
						}
					}
					
					repairedTrace.add(constructorEvent);
				}
			}
			

			//for run() method, it is invoked by another thread....
			for(XEvent originalEvent: originalTrace)
			{
				if(XConceptExtension.instance().extractName(originalEvent).equals("pattern1.clock.GlobalClock.run()")
						&&((XAttributeLiteral) originalEvent.getAttributes().get("apploc:etype")).getValue().equals("call")
						&& XLifecycleExtension.instance().extractTransition(originalEvent).equals("start"))
				{
					// add main event to trace
					XEvent runMethodEvent = factory.createEvent();
					XConceptExtension.instance().assignName(runMethodEvent, 
							GetMathodClassPackages.extractMethod(XConceptExtension.instance().extractName(originalEvent)));
					XLifecycleExtension.instance().assignTransition(runMethodEvent, "start");
					XSoftwareExtension.instance().assignClass(runMethodEvent, 
							GetMathodClassPackages.extractClass(XConceptExtension.instance().extractName(originalEvent)));
					XSoftwareExtension.instance().assignPackage(runMethodEvent, 
							GetMathodClassPackages.extractPackage(XConceptExtension.instance().extractName(originalEvent)));
					XSoftwareExtension.instance().assignParameterTypeSet(runMethodEvent, 
							GetMathodClassPackages.extractParameterSet(XConceptExtension.instance().extractName(originalEvent)));	
					XSoftwareExtension.instance().assignLineNumber(runMethodEvent,
							Integer.parseInt(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:linenr")).getValue()));
					XSoftwareExtension.instance().assignThreadID(runMethodEvent,
							Integer.parseInt(((XAttributeLiteral) originalEvent.getAttributes().get("apprun:threadid")).getValue()));
					XSoftwareExtension.instance().assignStarttimenano(runMethodEvent, 
							((XAttributeLiteral) originalEvent.getAttributes().get("apprun:nanotime")).getValue());
					
					/*
					 * the parameter set and values.....
					 */
					
					//set the default values...
					XSoftwareExtension.instance().assignCallermethod(runMethodEvent, "NULL");
					XSoftwareExtension.instance().assignCallerclass(runMethodEvent, "NULL");
					XSoftwareExtension.instance().assignCallerclassobject(runMethodEvent, "0");
					XSoftwareExtension.instance().assignCallerpackage(runMethodEvent, "NULL");
					
					XSoftwareExtension.instance().assignEndtimenano(runMethodEvent, 
							((XAttributeLiteral) originalEvent.getAttributes().get("apprun:nanotime")).getValue());
					XSoftwareExtension.instance().assignClassObject(runMethodEvent, "0");
					
					//get the object id of each run(), according to the caller information of its invoked methods.
					
					//add the complete time by matching its complete event. 
					//because for static event, the object and name are the same, 
					//we use the first complete event after the index of current one.
					int startRunIndex = originalTrace.indexOf(originalEvent);
					int endRunIndex =0;
					
					for (int j=startRunIndex;j<originalTrace.size();j++)
					//for (XEvent tempEvent: originalTrace)
					{	
						if ( ((XAttributeLiteral) originalTrace.get(j).getAttributes().get("apploc:joinpoint")).getValue().
								equals(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:joinpoint")).getValue())
								&& XLifecycleExtension.instance().extractTransition(originalTrace.get(j)).equals("complete"))
						{
							XSoftwareExtension.instance().assignEndtimenano(runMethodEvent, 
									((XAttributeLiteral) originalTrace.get(j).getAttributes().get("apprun:nanotime")).getValue());
							endRunIndex=j;
							break;
						}
					}
					
					//we check the event between start run and end run, find methods whose caller is run(),
					if(endRunIndex-startRunIndex>1)
					{
						for(int m=startRunIndex+1;m<endRunIndex;m++)
						{
							if(((XAttributeLiteral) originalTrace.get(m).getAttributes().get("apploc:caller:joinpoint"))!=null)
							{
								System.out.println(originalTrace.get(m).getAttributes().get("apploc:joinpoint"));
								if(((XAttributeLiteral) originalTrace.get(m).getAttributes().get("apploc:caller:joinpoint")).getValue().
										equals(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:joinpoint")).getValue()))
								{
									XSoftwareExtension.instance().assignClassObject(runMethodEvent, 
											((XAttributeLiteral) originalTrace.get(m).getAttributes().get("apploc:caller:idhashcode")).getValue());
								}
							}
							
						}
					}

					repairedTrace.add(runMethodEvent);
				}
			}
		
			
			// add normal method calls. 
			for(XEvent originalEvent: originalTrace)
			{
				if(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:etype")).getValue().equals("call")
						&& XLifecycleExtension.instance().extractTransition(originalEvent).equals("start")
						&& !XConceptExtension.instance().extractName(originalEvent).contains("main(java.lang.String[])")// not main
						&&!XConceptExtension.instance().extractName(originalEvent).contains("pattern1.clock.GlobalClock.run()")//not run....
						)
				{
					// add main event to trace
					XEvent normalMethodEvent = factory.createEvent();
					
					XConceptExtension.instance().assignName(normalMethodEvent, 
							GetMathodClassPackages.extractMethod(XConceptExtension.instance().extractName(originalEvent)));
					XLifecycleExtension.instance().assignTransition(normalMethodEvent, "start");
					XSoftwareExtension.instance().assignClass(normalMethodEvent, 
							GetMathodClassPackages.extractClass(XConceptExtension.instance().extractName(originalEvent)));
					XSoftwareExtension.instance().assignPackage(normalMethodEvent, 
							GetMathodClassPackages.extractPackage(XConceptExtension.instance().extractName(originalEvent)));
					XSoftwareExtension.instance().assignClassObject(normalMethodEvent, 
							((XAttributeLiteral) originalEvent.getAttributes().get("apploc:idhashcode")).getValue());
					//XSoftwareExtension.instance().assignComponent(event, calleeComponentName);
					
					XSoftwareExtension.instance().assignLineNumber(normalMethodEvent,
							Integer.parseInt(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:linenr")).getValue()));
					XSoftwareExtension.instance().assignThreadID(normalMethodEvent,
							Integer.parseInt(((XAttributeLiteral) originalEvent.getAttributes().get("apprun:threadid")).getValue()));

					
					
					//add parameter type and values.
					String paramTypes= GetMathodClassPackages.extractParameterSet(XConceptExtension.instance().extractName(originalEvent));
					XSoftwareExtension.instance().assignParameterTypeSet(normalMethodEvent, 
							paramTypes);	
					//add the parameter values, each value corresponds to a type. 
					String paramValues = "";
					if(paramTypes.contains(","))// more than one parameter
					{
						for(int j=1; j<=paramTypes.trim().split("\\,").length;j++)
						{
							if(j!=paramTypes.trim().split("\\,").length)// not the last one, we add a , at the end
							{
								paramValues=paramValues+((XAttributeLiteral) originalEvent.getAttributes().get("apploc:params:param"+j)).getValue()+",";
							}
							else{// for the last parameter, we do not add , at the end
								paramValues=paramValues+((XAttributeLiteral) originalEvent.getAttributes().get("apploc:params:param"+j)).getValue();
							}
							
						}
						XSoftwareExtension.instance().assignParameterValueSet(normalMethodEvent, 
								paramValues);	
					}
					else if (paramTypes.contains("."))// only one parameter
					{
						XSoftwareExtension.instance().assignParameterValueSet(normalMethodEvent, 
								((XAttributeLiteral) originalEvent.getAttributes().get("apploc:params:param1")).getValue());	
					}
					else{ //no parameter
						XSoftwareExtension.instance().assignParameterValueSet(normalMethodEvent, 
								paramValues);	
					}
								
					
					// if the caller of the current method is main()
					if (((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue().contains("main(java.lang.String[])"))
					{
						if (mainFlag==1)// the log contains main, i.e., pacClassMethodMain is not null;
						{
							XSoftwareExtension.instance().assignCallermethod(normalMethodEvent, GetMathodClassPackages.extractMethod(pacClassMethodMain));
							XSoftwareExtension.instance().assignCallerclass(normalMethodEvent, GetMathodClassPackages.extractClass(pacClassMethodMain));
							XSoftwareExtension.instance().assignCallerclassobject(normalMethodEvent, classObjectMain);
							XSoftwareExtension.instance().assignCallerpackage(normalMethodEvent, GetMathodClassPackages.extractPackage(pacClassMethodMain));
							//XSoftwareExtension.instance().assignCallercomponent(event, callerComponentName);
						}
						else{// pacClassMethodMain is null
							XSoftwareExtension.instance().assignCallermethod(normalMethodEvent, GetMathodClassPackages.extractMethod(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
							XSoftwareExtension.instance().assignCallerclass(normalMethodEvent, GetMathodClassPackages.extractClass(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
							XSoftwareExtension.instance().assignCallerclassobject(normalMethodEvent, classObjectMain);
							XSoftwareExtension.instance().assignCallerpackage(normalMethodEvent, GetMathodClassPackages.extractPackage(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
						}
						
					}
					else// if the caller of the current method is not main()
					{
						// if the caller of the current method is not a constructor.
						if(!constructorJoinPointNames.contains(((XAttributeLiteral)originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()))
						{
							XSoftwareExtension.instance().assignCallermethod(normalMethodEvent, 
									GetMathodClassPackages.extractMethod(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
							XSoftwareExtension.instance().assignCallerclass(normalMethodEvent, 
									GetMathodClassPackages.extractClass(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
							XSoftwareExtension.instance().assignCallerclassobject(normalMethodEvent, 
									((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:idhashcode")).getValue());
							XSoftwareExtension.instance().assignCallerpackage(normalMethodEvent, 
									GetMathodClassPackages.extractPackage(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
						}
						else // if the caller is a constructor.
						{
							XSoftwareExtension.instance().assignCallermethod(normalMethodEvent, "init()");
							XSoftwareExtension.instance().assignCallerclass(normalMethodEvent, 
									GetMathodClassPackages.extractConstructorClass(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
							XSoftwareExtension.instance().assignCallerclassobject(normalMethodEvent, 
									((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:idhashcode")).getValue());
							XSoftwareExtension.instance().assignCallerpackage(normalMethodEvent, 
									GetMathodClassPackages.extractConstructorPackage(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:caller:joinpoint")).getValue()));
						}
						
					}
					
					XSoftwareExtension.instance().assignStarttimenano(normalMethodEvent, 
							((XAttributeLiteral) originalEvent.getAttributes().get("apprun:nanotime")).getValue());
					
					//add the complete time by matching its complete event. 
					//because for static event, the object and name are the same, 
					//we use the first complete event after the index of current one.
					int originalEventIndex = originalTrace.indexOf(originalEvent);
					
					for (int j=originalEventIndex;j<originalTrace.size();j++)
					//for (XEvent tempEvent: originalTrace)
					{	
						if(!XConceptExtension.instance().extractName(originalTrace.get(j)).contains("pattern1.clock.GlobalClock.run()")&&
								!XConceptExtension.instance().extractName(originalTrace.get(j)).contains("main(java.lang.String[])"))
						{
							if (	((XAttributeLiteral) originalTrace.get(j).getAttributes().get("apploc:idhashcode")).getValue().
									equals(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:idhashcode")).getValue())
									&&((XAttributeLiteral) originalTrace.get(j).getAttributes().get("apploc:joinpoint")).getValue().
									equals(((XAttributeLiteral) originalEvent.getAttributes().get("apploc:joinpoint")).getValue())
									&& XLifecycleExtension.instance().extractTransition(originalTrace.get(j)).equals("complete")
									)
							{
								XSoftwareExtension.instance().assignEndtimenano(normalMethodEvent, 
										((XAttributeLiteral) originalTrace.get(j).getAttributes().get("apprun:nanotime")).getValue());
								break;
							}
						}
						
					}
					
					repairedTrace.add(normalMethodEvent);
				}
			}
			
			
			
			repairedLog.add(repairedTrace);	
		}
		
		// order the re-factored trace using the nano-seconds attribute. 		
		return OrderingEventsNano.ordering(repairedLog, XSoftwareExtension.KEY_STARTTIMENANO);
	}
	
	
}
